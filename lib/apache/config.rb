require 'fileutils'

Dir[File.join(File.dirname(__FILE__), '*.rb')].each { |f| require f }

module Apache
  class Config
    class << self
      attr_accessor :line_indent, :rotate_logs_path

      include Apache::Master
      include Apache::Quoteize
      include Apache::Permissions
      include Apache::Directories
      include Apache::Logging
      include Apache::Performance
      include Apache::Rewrites
      include Apache::MPM

      # Build the provided configuration only if the current environment matches one of the conditions
      def build_if(target, *conditions, &block)
        build(target, &block) if conditions.include? APACHE_ENV
      end

      # Build the provided configuration
      def build(target = nil, &block)
        reset!

        self.instance_eval(&block)

        if target
          FileUtils.mkdir_p File.split(target).first
          File.open(target, 'w') { |f| f.puts [ "# Generated by apache-config-generator #{Time.now.to_s}", @config ].flatten * "\n" }
        end

        @config
      end

      # Reset the current settings
      def reset!
        @config = []
        @line_indent = 0
      end

      # Indent the string by the current @line_indent level
      def indent(string_or_array)
        case string_or_array
          when Array
            string_or_array.collect { |s| indent(s) }
          else
            " " * (@line_indent * 2) + string_or_array.to_s
        end
      end

      # Add the string to the current config
      def <<(string)
        @config << indent(string)
      end

      # Append the array to the current config
      def +(other)
        @config += other
      end

      # Get the config
      def to_a
        @config
      end

      # Apachify a string
      #
      # Split the provided name on underscores and capitalize the individual parts
      def apachify(name)
        case name
          when String, Symbol
            name.to_s.split("_").collect(&:capitalize).join.gsub('Ssl', 'SSL').gsub('Cgi', 'CGI').gsub('Ldap', 'LDAP').gsub('Url', 'URL')
          when Array
            name.collect { |n| apachify(n) }
        end
      end

      # Handle options that aren't specially handled
      def method_missing(method, *args)
        if method.to_s[-1..-1] == "!"
          method = method.to_s[0..-2].to_sym
        else
          args = *quoteize(*args)
        end

        self << [ apachify(method), *args ].compact * ' '
      end

      # Handle creating block methods
      def block_methods(*methods)
        methods.each do |method|
          self.class.class_eval <<-EOT
            def #{method}(*name, &block)
              blockify(apachify("#{method}"), name, &block)
            end
          EOT
        end
      end

      def if_module(mod, &block)
        blockify(apachify('if_module'), "#{mod}_module".to_sym, &block)
      end

      def directory(dir, &block)
        directory? dir
        blockify(apachify('directory'), dir, &block)
      end

      def location_match(regexp, &block)
        blockify(apachify('location_match'), regexp.source, &block)
      end

      def if_environment(env, &block)
        self.instance_eval(&block) if APACHE_ENV == env
      end

      def blockify_name(name)
        case name
          when String
            quoteize(name).first
          when Array
            (quoteize(*name) * " ")
          when Symbol
            name.to_s
        end
      end

      # Handle the blockification of a provided block
      def blockify(tag_name, name, &block)
        self << ""
        self << "<#{[ tag_name, blockify_name(name) ].compact * ' '}>"
        @line_indent += 1
        self.instance_eval(&block)
        @line_indent -= 1
        self << "</#{tag_name}>"
        self << ""
      end

      def rotatelogs(path, time)
        "|#{@rotate_logs_path} #{path} #{time}"
      end

      private
        def writable?(path)
          puts "[warn] #{path} may not be writable!" if !File.directory? File.split(path).first
        end

        def directory?(path)
          puts "[warn] #{path} does not exist!" if !File.directory? path
        end

        def exist?(path)
          puts "[warn] #{path} does not exist!" if !File.exist?(path)
        end
    end

    block_methods :virtual_host, :files_match, :location, :files
  end
end
